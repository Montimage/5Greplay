<beginning>

<!-- 
This rule set IP protocol via user inputs:
- ip-src
- ip-dst

sudo ./5greplay replay -t pcap/oai.pcap -Xengine.exclude-rules=1-109 -Uip-src=1.1.1.1 -Uip-dst=1.2.3.4
 -->

<embedded_functions><![CDATA[

#pragma pack(push, 1)  // Ensure no padding between fields
typedef struct {
	uint8_t  version_ihl;    // Version (4 bits) + IHL (4 bits)
	uint8_t  tos;            // Type of Service
	uint16_t total_length;   // Total length
	uint16_t identification; // Identification
	uint16_t flags_fragment; // Flags (3 bits) + Fragment offset (13 bits)
	uint8_t  ttl;            // Time to Live
	uint8_t  protocol;       // Protocol
	uint16_t checksum;       // Header checksum
	uint8_t  src[4];         // Source address
	uint8_t  dst[4];         // Destination address
	// Options may follow for IHL > 5
} ipv4_t;
#pragma pack(pop)

static ipv4_t ipv4;

static inline void _get_ip(uint8_t* ip, const char* name){
	const char *val;
	val = get_input( name );
	if( !val )
		return;
	
	int m[4];
	sscanf(val, "%d.%d.%d.%d", m+0, m+1, m+2, m+3);
	for(int i=0; i<4; i++)
		ip[i] = m[i];
}

// Calculate IPv4 header checksum
static inline uint16_t _checksum(const void *data, size_t length) {
	const uint16_t *ptr = (const uint16_t *)data;
	uint32_t sum = 0;
	
	// Sum all 16-bit words
	while (length > 1) {
		sum += *ptr++;
		length -= 2;
	}
	
	// Add left-over byte, if any
	if (length > 0)
		sum += *(const uint8_t *)ptr;
	
	// Fold 32-bit sum to 16 bits
	while (sum >> 16)
		sum = (sum & 0xFFFF) + (sum >> 16);
	
	return (uint16_t)~sum;
}

void on_load(){
	memset(&ipv4, 0, sizeof(ipv4));
	ipv4.version_ihl = (4 << 4) | 5;   // IPv4, 5 words header
	ipv4.ttl = 64;
	_get_ip(ipv4.src, "ip-src");
	_get_ip(ipv4.dst, "ip-dst");
}

// reuse total_length from the packet
static inline bool set_len( double val ){
	//printf("set length: %d\n", (int)val);
	ipv4.total_length = htons((int)val);
	return true;
}

// reuse proto_id from the packet
static inline bool set_proto( double val ){
	//printf("set protocol: %d\n", (int)val);
	ipv4.protocol = val;
	return true;
}

static void em_replace_ip(
		const rule_info_t *rule, int verdict, uint64_t timestamp, 
		uint64_t counter, const mmt_array_t * const trace ){

	ipv4.checksum = 0;
	ipv4.checksum = _checksum(&ipv4, sizeof(ipv4));

	replace_data_at_protocol_id( PROTO_IP, sizeof(ipv4), (const char *) &ipv4 );
}
]]></embedded_functions>

<property value="THEN" property_id="110" type_property="FORWARD" 
    description="Set new IP"
    if_satisfied="em_replace_ip">
    <event description="Got an IP packet on top of Ethernet"
           boolean_expression="(ethernet.proto == 2048)"/>
    <event description="Forward values"
           boolean_expression="( #set_proto(ip.proto_id) &amp;&amp; #set_len(ip.tot_len) )"/>
</property>

</beginning>